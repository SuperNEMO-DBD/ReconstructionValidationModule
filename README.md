# ValidationModule readme


Cheryl Patrick (UCL)
Last updated July 4th 2018

ValidationModule  is a Falaise pipeline module to process a selection of basic validation data and output a ROOT ntuple file, to be used for standard plots and metrics to validate data quality and basic reconstruction. The code is based on the SensitivityModule, but outputs completely different data. It should serve as an example for further validation modules; this one looks at reconstructed quantities like the number of reconstructed hits in an event or the reconstructed energy in a calorimeter.

## Files:

- ValidationModule.cpp
- ValidationModule.h
- CMakeLists.txt
- ValidationModuleExample.conf.in


## Description

Add to an flreconstruct pipeline to generate a ROOT ntuple file with some pertinent branches. To build it, do

``` console
$ ls
CMakeLists.txt                   SensitivityModule.h
README.md                        SensitivityModuleExample.conf.in
SensitivityModule.cpp
$ mkdir build
$ cd build
$ cmake -DCMAKE_PREFIX_PATH=<pathtoyourfalaiseinstall> ..
...
$ make
...
... If you are developing the module, you can test it by doing ...
$ make test
```

Note: if you get a QT5 error, you may need to specify the QT5 path when you run the cmake line, as given by `brew --prefix qt5-base`. For example, you can run:
``` console
$ cmake -DCMAKE_PREFIX_PATH="$(brew --prefix qt5-base);$(brew --prefix)" ..
``` 

The build will create the `libValidationModule` shared library plus the example `flreconstruct` pipeline
script `ValidationModuleExample.conf`. Assuming that you have an `input.brio` file that contains
the `SD`, `CD`, `TCD`, `TTD` and `PTD` banks from the full reconstruction pipeline of `flreconstruct`
(up to and including gamma clustering), this can be run as:

``` console
... Assume we run in the build dir ...
$ ls
CMakeCache.txt                SensitivityModuleExample.conf
CMakeFiles                    cmake_install.cmake
Makefile
...
$ flreconstruct -i /path/to/input.brio -p ValidationModuleExample.conf
...
$ ls
CMakeCache.txt                ValidationModuleExample.conf
CMakeFiles                    cmake_install.cmake
Makefile                      Validation.root
```

The output file will by default be called `Validation.root` so donâ€™t run it multiple times concurrently in the same directory
or you will overwrite the previous file! Use the falaise flreconstruct pipeline instructions to see how to integrate this module in your pipeline.

There is now the option to configure the output filename in the module configuration file.
The final two lines of the configuration file must read:

[name="processing" type="ValidationModule"]
filename_out : string[1] = "my_filename.root"

## Types of branch

The ValidationParser will process the output tuples, making standard plots and (in future) comparing them to reference distributions. In order for it to do so, you need to follow some naming and formatting conventions when you create the branches. The branch name prefix tells the program how to process the information in the branch. The parser knows how to deal with the following types of branch:

**Simple Histogram branches:** prefix: `h_`

Example: `h_total_calorimeter_energy`. The information in these branches will simply be histogrammed. A config file can be used to select the number of bins, and the minimum and maximum x values - otherwise they will be autogenerated. The config file can also give a title for the plots generated. If no title is specified, the parser will generate one by formatting the branch name, replacing underscores by spaces. For example, `h_calorimeter_hit_count` will get a default title of "Calorimeter hit count". An example config file line for a histogram variable is `h_cluster_count, Number of clusters, 10,0,10` which would tell you to entitle the plot for `h_cluster_count` "Number of clusters" and to use 10 bins, starting at 0 and going up to 10. Any of these fields can be left blank, or you can just not make an entry at all in the config file.

**Tracker map branches:** prefix: `t_`

Example: `t_cell_hit_count`. This stores an encoded location (cell identifier) in the tracker. To use one of these branches, you MUST encode the location of each hit using the `EncodeLocation` function, then push it to a vector. In this example, `t_cell_hit_count` just stores the location of every Geiger hit but you could make a branch that stored something different - for example, only delayed hits.

This will produce a 2-d heat-map of the tracker, showing how many times each location was logged. For weighted maps, see the `tm_` prefix.

  The config file allows you to set the title of this, as for the `h_` type branches.

**Tracker average branches:** prefix: `tm_`

Example: `tm_average_drift_radius.t_cell_hit_count`. This will map the mean of some value over the tracker. In order to do so, you need to push the value you want to average to a vector, in the same order that you pushed a location. The locations should be in the branch named after the `.` in the branch name.

This is confusing so here is an example. Let's say we have an event with 2 Geiger hits: one has a radius of 10mm, at tracker location (1,2). The other has a radius of 15mm, at tracker location (1,3). We will push two entries to the `tm_average_drift_radius.t_cell_hit_count branch`: 10 and 15. We will push two locations to the `t_cell_hit_count` branch - the encoded locations corresponding to (1,2) and (1,3). The parser will note that those radii (10 and 15) occurred at those locations ((1,2) and (1,3)) and include them when calculating the average radius recorded in the (1,2) and (1,3) cells.

The uncertainties on these are given by creating a partnered branch with no suffix ("." and map branch name), and with "tm_" changed to "err_". Again, the uncertainties must be pushed to this vector in the same order as the values in the main branch.

**Calorimeter branches:** prefix: `c_`

Example: `c_calorimeter_hit_map`.  This stores an encoded location (calorimeter identifier). To use one of these branches, you MUST encode the location of each hit using the `EncodeLocation` function, then push it to a vector. In this example, `c_calorimeter_hit_map` just stores the location of every calorimeter hit but you could make a branch that stored something different - for example, only hits associated with a track.

This will produce a 2-d heat-map of each calorimeter wall, showing how many times each location was logged. The 6 walls will be presented together as an image. For weighted maps, see the `cm_` prefix.

**Calorimeter average branches:** prefix: `cm_`

Example: `cm_average_calorimeter_energy.c_calorimeter_hit_map`. This will map the mean of some value over the 6 calorimeter walls. In order to do so, you need to push the value you want to average to a vector, in the same order that you pushed a location. The locations should be in the branch named after the `.` in the branch name.

This is confusing so here is an example. Let's say we have an event with 2 calorimeter hits: one is of 2MeV, at location (3,4) on the Italian wall. The other has energy 1.5 MeV, at at location (2,7) on the French wall. We will push two entries to the `cm_average_calorimeter_energy.c_calorimeter_hit_map`: 2 and 1.5. We will push two locations to the `c_calorimeter_hit_map` branch - the encoded locations corresponding to (3,4) on the Italian wall and (2,7) on the French wall. The parser will note that those energies (2 and 1.5) were measured at those calorimeter locations, and include them in the average-energy calculation for those 2 particular calorimeter modules.

The uncertainties on these are given by creating a partnered branch with no suffix ("." and map branch name), and with "cm_" changed to "err_". Again, the uncertainties must be pushed to this vector in the same order as the values in the main branch.



## Branches in this tuple

**h_calorimeter_hit_count** : Total number of reconstructed calorimeter hits

**h_calo_hits_over_threshold** : Total number of reconstructed calorimeter hits above the 50keV trigger threshold

**h_cluster_count** : Total number of reconstructed clusters

**h_track_count** : Total number of reconstructed tracks (not including gamma 'tracks')

**h_negative_track_count** : Tracks with negative charge (from curvature, assuming coming from foil)

**h_positive_track_count** : Tracks with positive charge (from curvature, assuming coming from foil)

**h_associated_track_count** : Number of tracks with associated calo hit

**h_geiger_hit_count** : Total number of tracker hits

**v_all_track_hit_counts** : Vector of the number of tracker hits in each individual track

**h_total_calorimeter_energy** : Summed energy in all calorimeters (MeV)

**h_calo_energy_over_threshold** : Summed energy in all calorimeters (MeV) of calorimeter hits above the 50keV trigger threshold

**h_unassociated_calorimeter_energy** : Summed energy in calorimeters not associated to tracks (considered to be gammas) (MeV)

**h_unassociated_energy_over_threshold** : Summed energy in calorimeters for hits over 50keV that are not associated to tracks (considered to be gammas) (MeV)

**h_associated_calorimeter_energy** : Summed calo energy associated to tracks (MeV)

**h_associated_energy_over_threshold** : Summed calo energy for hits over 50keV that are associated to tracks (MeV)

**h_calo_hit_time_separation** Time in ns between first and last calorimeter hits

**t_cell_hit_count** Vector of tracker cells that have a geiger hit. Encoded using the EncodeLocation function

**tm_average_drift_radius.t_cell_hit_count** Vector of drift radii for each Geiger hit in mm. The order of the hits corresponds to the order of cell locations in t_cell_hit_count

**err_average_drift_radius** Vector of uncertainties on the drift radii for each Geiger hit in mm. The order of the hits corresponds to the order of hit locations in tm_average_drift_radius. It's important that the names match, with "err_" prefix, and with no "." suffix 

**c_calorimeter_hit_map** Vector with all calorimeter hit locations, encoded using EncodeLocation

**cm_average_calorimeter_energy.c_calorimeter_hit_map** Vector of energies of calorimeter hits in MeV. The order of the hits corresponds to the order of hit locations in c_calorimeter_hit_map

**err_average_calorimeter_energy** Vector of uncertainties on the energies of calorimeter hits in MeV. The order of the hits corresponds to the order of hit locations in cm_average_calorimeter_energy. It's important that the names match, with "err_" prefix, and with no "." suffix 
